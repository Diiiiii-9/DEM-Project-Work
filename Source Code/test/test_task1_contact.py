# test_task1_contact.py

import sys
import os

current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)


import unittest
import numpy as np
from dem.particle import Particle
from dem.contact_model import HertzMindlinDashpot

class TestContactModel(unittest.TestCase):
    def setUp(self):
        """
        Setup run before each test method.
        Initializes basic parameters for particles and the contact model.
        """
        # Define dummy material properties
        self.params = {
            "coeff_of_restitution": 0.9,
            "mu": 0.5  # Friction coefficient for testing
        }
        self.model = HertzMindlinDashpot(self.params)
        
        # Define common particle properties
        # Position, Velocity, Omega, Radius, Mass, E, nu
        self.p1 = Particle([0, 0, 0], [0, 0, 0], [0, 0, 0], 1.0, 1.0, 1e5, 0.3, particle_id=1)
        self.p2 = Particle([2.5, 0, 0], [0, 0, 0], [0, 0, 0], 1.0, 1.0, 1e5, 0.3, particle_id=2)
        
        # Time step
        self.dt = 0.01

    def test_no_contact(self):
        """
        Test 1: Verify that zero force is returned when particles are apart.
        """
        # Set p2 far away (distance 2.5 > radius 1 + 1)
        self.p2.position = np.array([2.5, 0.0, 0.0])
        
        force, t1, t2 = self.model.compute_contact(self.p1, self.p2, self.dt)
        
        # Assert forces are zero
        np.testing.assert_array_equal(force, np.zeros(3), "Force should be zero when no contact")
        np.testing.assert_array_equal(t1, np.zeros(3), "Torque1 should be zero when no contact")

    def test_normal_force_only(self):
        """
        Test 2: Pure normal overlap should produce Normal Force but NO Tangential Force.
        """
        # Place p2 to overlap with p1 along X-axis
        # Radius sum = 2.0. Distance = 1.9. Overlap = 0.1
        self.p2.position = np.array([1.9, 0.0, 0.0])
        
        force, t1, t2 = self.model.compute_contact(self.p1, self.p2, self.dt)
        
        # Check Normal Force (X-direction)
        self.assertLess(force[0], 0, "Force on p1 should be negative (repulsive) in X")
        
        # Check Tangential Force (Y-direction)
        self.assertAlmostEqual(force[1], 0.0, places=5, msg="Tangential force should be zero for pure normal collision")
        
        # Check Torque
        self.assertAlmostEqual(np.linalg.norm(t1), 0.0, places=5, msg="Torque should be zero for pure normal collision")

    def test_tangential_force_generation(self):
        """
        Test 3: Verify that tangential relative motion generates Tangential Force and Torque.
        (The "Spring" behavior)
        """
        # 1. Establish normal contact first
        self.p2.position = np.array([1.9, 0.0, 0.0])
        
        # 2. Give p2 a velocity in Y direction (Shear motion)
        self.p2.velocity = np.array([0.0, 1.0, 0.0])
        self.p1.velocity = np.array([0.0, 0.0, 0.0])
        
        # 3. Compute contact
        force, t1, t2 = self.model.compute_contact(self.p1, self.p2, self.dt)
        
        # Check that we have a Y-force (Tangential)
        # p2 moves UP (+Y). p1 sticks to p2, so p1 should be pulled UP (+Y) by the spring force?
        # Or p1 feels friction resisting p2? 
        # Actually, let's just check magnitude is non-zero.
        self.assertNotEqual(force[1], 0.0, "Tangential force should be generated")
        
        # Check Torque generation (Tangential force at radius creates torque)
        self.assertNotEqual(np.linalg.norm(t1), 0.0, "Torque should be generated by tangential force")
        
        # Check History Storage
        # The model should have stored the displacement in p1.tangential_overlaps
        self.assertIn(self.p2.id, self.p1.tangential_overlaps, "Tangential history should be stored")
        stored_overlap = self.p1.tangential_overlaps[self.p2.id]
        self.assertNotEqual(np.linalg.norm(stored_overlap), 0.0, "Stored overlap should be non-zero")

    def test_coulomb_friction_limit(self):
        """
        Test 4: Verify that Tangential Force is capped by Coulomb Friction (Task 1 requirement).
        F_t <= mu * F_n
        """
        # 1. Establish normal contact
        self.p2.position = np.array([1.9, 0.0, 0.0]) # 0.1 Overlap
        
        # 2. Simulate a HUGE sliding step to force the spring to stretch beyond friction limit
        # Moving p2 extremely fast in Y
        self.p2.velocity = np.array([0.0, 1000.0, 0.0]) 
        
        force, t1, t2 = self.model.compute_contact(self.p1, self.p2, self.dt)
        
        # Extract components
        f_normal = abs(force[0])    # Force in X
        f_tangential = abs(force[1]) # Force in Y
        
        # Calculate expected limit
        mu = self.params["mu"]
        expected_limit = mu * f_normal
        
        # Check if tangential force respects the limit (allow small numerical tolerance)
        self.assertAlmostEqual(f_tangential, expected_limit, delta=1e-5, 
                               msg=f"Tangential force {f_tangential} should be capped at {expected_limit}")

if __name__ == '__main__':
    unittest.main()